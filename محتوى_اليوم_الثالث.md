# محتوى اليوم الثالث
Lombok-Validation-Service




# ماهو Lombok :

Project Lombok is a java library tool that is used to minimize/remove the boilerplate code and save the precious time of developers during development by just using some annotations. In addition to it, it also increases the readability of the source code and saves space.


**Lombok annotations:** Lombok provides a set of annotations to make our coding life easier. Let us look at the few most frequently used annotations of Lombok. 

**@Getter and @Setter:** 
These annotations provide the getter and setter methods for a field. These annotations can be used at both the levels, field as well as class. *@Getter* annotation generates a getter method with access type as public which simply returns the field and with name getName() if the field name is “Name”. *@Setter* annotation generates a setter method with access type as public which returns void and takes a single parameter to assign the value to the field. The default setter will have the name setName() if the field name is “Name”. 

**@NoArgsConstructor:** 
This annotation is used to generate a constructor with no arguments. It has an empty body and does nothing. It is generally used in combination with some other parameterized constructor in use. It is required when you want to generate an object of the class by passing no arguments in the constructor. 

**@AllArgsConstructor:** 
This annotation is used to generate a parameterized constructor which accepts a single parameter for each field and initializes them using it. It is required when you want to generate an object of the class by passing the initial values of the fields in the constructor. 

**@ToString:** 
This annotation is used to override the toString() method and generate a default implementation for it. The default implementation prints the class name and the fields in order, separated by commas. You can also skip some fields that you don’t want to print by annotating them with *@ToString.Exclude*. 

**@EqualsAndHashCode:** 
This annotation is used to override the equals() and hashCode() methods and provides a default implementation for thu. The default implementation uses all the non-static fields, and we can modify it and can exclude some fields using the annotation *@EqualsAndHashCode.Exclude*. 


**@Data:** 
This annotation is a shortcut annotation and bundles *@ToString*, *@Getter*, *@Setter*, *@EqualsAndHashCode* and *@RequiredArgsConstructor* annotations into a single annotation. This annotation provides all the normally used boilerplate code in the model classes of java like getters for all the fields, setter for all the non-final fields, a default implementation for toString(), equals() and hashCode() using all the fields of the class and a constructor that initializes all the fields of the class. 


----------


# ماهو Validation :

The Spring Validation is used to restrict the input provided by the user. To validate the user's input, the Spring 4 or higher version supports and use Bean Validation API. It can validate both server-side as well as client-side applications.


| Annotation                  | Description                                                                                                                                |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| @NotNull                    | It determines that the value can't be null.                                                                                                |
| @Min                        | It determines that the number must be equal or greater than the specified value.                                                           |
| @Max                        | It determines that the number must be equal or less than the specified value.                                                              |
| @Size                       | It determines that the size must be equal to the specified value.                                                                          |
| @Pattern                    | It determines that the sequence follows the specified regular expression.                                                                  |
| @NotEmpty                   | validates that the property is not null or empty; can be applied to *String*, *Collection*, *Map* or *Array* values.                       |
| @NotBlank                   | can be applied only to text values and validates that the property is not null or whitespace.                                              |
| @Positive & @PositiveOrZero | apply to numeric values and validate that they are strictly positive, or positive including 0.                                             |
| @Negative &@NegativeOrZero  | apply to numeric values and validate that they are strictly negative, or negative including 0.                                             |
| @Past & @PastOrPresent      | validate that a date value is in the past or the past including the present; can be applied to date types including those added in Java 8. |
| @Future & FutureOrPresent   | validate that a date value is in the future, or in the future including the present.                                                       |
| @Email                      | validate that the value is a valid email                                                                                                   |



![](https://paper-attachments.dropbox.com/s_957A21FD492D515AFC0F89EE8B0F18F1E8694BFC0AC3DD84EAB83FD81B96E7F4_1651143739861_image.png)

----------


# ماهو Service

**The service layer** (domain) contains your business logic. It defines which functionalities you provide, how they are accessed, and what to pass and get in return - **independent on any port (of which there may be multiple: web services, message queues, scheduled events) and independent on its internal workings.**

The business logic may start simple in the beginning, and offer not more that simple CRUD operations, but that doesn't mean it will forever stay this way. As soon as you need to deal with access rights, it's no longer a matter of routing requests from the controller directly to the repository, but checking access and filtering data as well. Requests may need validation and consistency checks before hitting the database, rules and additional operations may be applied, so your **services get more value over time**.


